/*
 * excelcsv
 *
 * Copyright (c) 2014 Jason Pescione
 * Licensed under the MIT license.
 *
 * @file
 *   All methods are public so they can be properly unit tested.
 *   Method and properties prefiexed w/ an underscore should not be modified by a user.
 *
 * @todo
 *   add some proper error handling
 *   it would be nice to make this async, but the xlsx read method, the most expensive operation, is synchrnous, so idk if it's worth it.
 *   add commas should be optional
 *   add some more/better tests
 */

'use strict';

var fs     = require('fs')
  , xlsx   = require('xlsx')
  , _      = require('lodash')
  , semver = require('semver');

/**
 * @param {string} fileIn path to the .xls||.xlsx file to be parsed.
 * @param {string} fileOut path of the outputted CSV.
 */
var ExcelCSV = function( fileIn, fileOut ) {

  /**
   * Constructor
   */
  (function() {
    if ( !fileIn )
      throw 'Make sure you have passed values for both fileIn to the constructor.';

    this._fileIn  = fileIn;
    this._fileOut = fileOut || '';
    fileIn = fileOut = undefined; // Force use of the public properties.

  }).call(this);

  /**
   * Set by this.header()
   * @type {Array}
   */
  this._header = [];

  /**
   * Synchronously read all worksheets in a .xlsx workbook.
   * @param {string} filepath
   * @return {multidimensional object}
   */
  this._readWorksheets = function( filepath ) {
    return xlsx.readFile( filepath );
  };

  /**
   * Get the x-axis difference, between two
   * excel coordinates. e.g. "A1" and "B1" would be 1
   * @param  {string} start e.g. "A1"
   * @param  {string} end   e.g. "B1"
   * @return {number}
   */
  this._diffXCoordinates = function( start, end ) {
    var base = 0;
    start = start.match(/[a-zA-Z]+/)[0];
    end   = end.match(/[a-zA-Z]+/)[0];

    function reduce(str) {
      if (str.length > 1) {
        str = str.slice(1);
        base += 26;
        return reduce(str);
      }
      return str;
    }

    start = reduce(start);
    end = reduce(end);

    return base + end[0].charCodeAt() - start[0].charCodeAt();
  };

  /**
   * Get the y-axis difference, between two
   * excel coordinates. e.g. "A1" and "A2" would be 1
   * @param  {string} start e.g. "A1"
   * @param  {string} end   e.g. "A2"
   * @return {number}
   */
  this._diffYCoordinates = function( start, end ) {
    return end.match(/[0-9]+/)[0] - start.match(/[0-9]+/)[0];
  };

  /**
   * Given an x-coordinate return the next x-coordinate.
   * @param  {string} xCoordinate e.g. The x-coordinate for
   * "A1" would be "A" and the x-coordinate for "F5" would be "F"
   * @param {int} [increment] e.g. if given A and increment is 1,
   * "B" is returned. If increment was 2, "C" would be returned.
   * @return {string} e.g. if given F, should return G
   */
  this._incrementXcoordinate = function( xCoordinate, increment ) {
    function chr(codePt) {
      if (codePt > 0xFFFF) {
        codePt -= 0x10000;
        return String.fromCharCode(0xD800 + (codePt >> 10), 0xDC00 + (codePt & 0x3FF));
      }
      return String.fromCharCode(codePt);
    }

    function getNameFromNumber(number) {
      var numeric = (number - 1) % 26
        , letter = chr(65 + numeric)
        , number2 = parseInt((number - 1) / 26, 10);

      if (number2 > 0)
        return getNameFromNumber(number2) + letter;
       else
        return letter;
    }

    function getNumberFromName(str) {
      var number  = 0
        , base    = 'A'.charCodeAt() - 1
        , letters = str.split("").reverse();

      letters.forEach(function(letter, i) {
        number += i*26*(letter.charCodeAt() - base);
      });

      return number += letters.slice(0,1).toString().charCodeAt() - base;
    }

    return getNameFromNumber( getNumberFromName(xCoordinate) + increment );
  };

  /**
   * Parse an XLSX worksheet, and set default values for
   * blank cells (not a support behavior of the xlsx npm reader).
   * @param  {multidimensional object} worksheet
   * @param  {string} worksheetName
   * @param  {int} rangeX
   * @param  {int} rangeY
   * @param  {string} startX
   * @param  {int} startY
   * @return {array of array}
   */
  this._parseXlsxWorksheet = function( worksheet, worksheetName, rangeX, rangeY, startX, startY ) {
    var cells  = rangeX * rangeY
      , index  = 0
      , posX   = startX
      , posY   = parseInt( startY, 10 )
      , chr    = ''
      , cell   = ''
      , row    = []
      , rows   = [];

    while ( cells ) {
      chr = this._incrementXcoordinate( posX, index );
      cell = worksheet[ chr+posY ] ? worksheet[ chr+posY ].v : '';
      row.push( cell );

      cells -= 1;
      index += 1;
      if ( index === rangeX ) {
        posY += 1;
        index = 0;
        row = this._parseRow( row, worksheetName );
        if ( row ) rows.push( row );
        row = [];
      }
    }

    return rows;
  };

  /**
   * Parse an multidimensional object of excel worksheet data
   * into an array of rows (array)
   * @param  {multidimensional object} worksheets
   * @return {array of arrays} returns the processed rows
   * of each worksheet.
   */
  this._parseXlsxWorksheets = function( worksheets ) {
    var self = this
      , rows = [];

    _.each(worksheets, function(worksheet, worksheetName) {
      var row         = []
        , count       = 0
        , coordinates = worksheet['!ref'].split(':')
        , rangeX      = self._diffXCoordinates( coordinates[0], coordinates[1] ) + 1
        , rangeY      = self._diffYCoordinates( coordinates[0], coordinates[1] ) + 1
        , startX      = coordinates[0].match(/[a-zA-Z]+/)[0]
        , startY      = coordinates[0].match(/[0-9]+/)[0];

      delete worksheet['!ref'];
      rows.push(self._parseXlsxWorksheet( worksheet, worksheetName, rangeX, rangeY, startX, startY ));

    });

    return _.flatten( rows, true );
  };

  /**
   * Modify a row, NOT by reference.
   * @param  {array} row
   * @param  {string} worksheetName
   * @return {array}
   */
  this._parseRow = function( row, worksheetName ) {
    return row;
  };

   /**
    * Add a row to the beginning of your file as a header.
    * @param {array of arrays} worksheets
    * @return {array of arrays} worksheets
    */
  this._addHeader = function( worksheets ) {
    if ( this._header.length ) worksheets.unshift( this._header );
    return worksheets;
  };

  /**
   * Format parsed worksheet data into a CSV string.
   * @param  {array of arrays} rows
   * @return {string}
   */
  this._formatCSV = function( rows ) {
    var self = this
      , str  = '';

    rows.forEach(function(row) {
      str += row.map( self._addCommas ).join(',').replace( /(\r\n|\n|\r)/gm, "\\n" ) + '\n';
    });
    return str;
  };

  /**
   * Synchronously write the CSV.
   *
   * @param {string} contents
   * @param {string} filepath
   * @param {string} [encoding]
   */
  this._writeFileSync = function( contents, filepath, encoding ) {
    encoding = encoding || 'utf8';
    encoding = semver.gte(process.version, '0.10.0') ? { encoding: encoding } : encoding;
    fs.writeFileSync( filepath, contents, encoding );
    console.log( filepath + ' created' );
  };

  /**
   * Synchronously read a file.
   * @param  {string} filepath
   * @param  {string} encoding
   * @return {string}
   */
  this.readFileSync = function( filepath, encoding ) {
    encoding = encoding || 'utf8';
    encoding = semver.gte(process.version, '0.10.0') ? { encoding: encoding } : encoding;
    return fs.readFileSync( filepath, encoding );
  };

  /**
   * Wrap a field in commas.
   * @param {string} field
   * @return {string}
   */
  this._addCommas = function( field ) {
    return '"' + field + '"';
  };

  /**
   * Adds a header
   * @param {array} header
   * @return {this}
   */
  this.header = function( header ) {
    if ( !_.isArray(header) || header.length < 1 )
      throw 'The ".header" method needs an array';
    this._header = header;
    return this;
  };

  /**
   * If desired by the user, replace the parseRow method,
   * to provide an interface to preprocess each row of data.
   * @param  {Function} fn( row, worksheetName )
   * @return {this}
   */
  this.row = function( fn ) {
    if ( typeof fn !== 'function') throw 'the ".row" method needs a function';
    this._parseRow = fn;
    return this;
  };

  /**
   * Main method.
   */
  this.init = function() {
    var self = this;

    console.log('Doing my thing.');
    console.log('I may take a few minutes depnding on amount of data...');

    var worksheets = this._readWorksheets( self._fileIn ).Sheets;
    var rows = self._parseXlsxWorksheets( worksheets );

    self._addHeader( rows );
    var csv = self._formatCSV( rows );

    if ( self._fileOut )
      self._writeFileSync( csv, self._fileOut, 'utf8' );

    return csv;
  };

};

module.exports = ExcelCSV;